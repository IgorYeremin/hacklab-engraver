# Generated by stepconf at Sun Mar  8 21:32:59 2009
# If you make changes to this file, they will be
# overwritten when you run stepconf again


loadrt trivkins
# graster thread
loadrt threads name1=mask-thread period1=[EMCMOT]BASE_PERIOD
# motion planner without base thread (offloaded to fpga)
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD key=[EMCMOT]SHMEM_KEY num_joints=[TRAJ]AXES

# mesa fpga driver
loadrt hostmot2
# 3 axis of stepgens
# TODO: use PWM to drive laser output for PPI
loadrt hm2_pci config=" num_encoders=0 num_pwmgens=1 num_stepgens=3"
setp    hm2_5i25.0.watchdog.timeout_ns 5000000
# PID for velocity control of stepgens
loadrt pid names=pid.x,pid.y,pid.w

loadrt charge_pump


# Boring components that emc makes us load explicitly
loadrt comp names=comp-mask-lte,comp-laser-zaxis
loadrt not names=not-mask-ffw,not-mask-not-empty,not-jogger,not-amused,not-machinetoggle
loadrt xor2 names=xor2-mask-test
loadrt and2 names=and2-mask-forward,and2-laser-gmask,and2-laser-final,and2-jogger,and2-machineoff,and2-machineon
loadrt or2 names=or2-mask-command-done,or2-mask-not-ffw,or2-mask-read,or2-laser-gcode,or2-laser-fine
loadrt encoder num_chan=1

#Custom components added 2018/03
loadrt binaryscaler names=bs1
loadrt laserpwmcalc names=lpc1


# Slow thread for logic (more logic components are added further down)
addf hm2_5i25.0.read              servo-thread
addf bs1                          servo-thread
addf motion-command-handler       servo-thread
addf motion-controller            servo-thread
addf lpc1			  servo-thread
addf pid.x.do-pid-calcs           servo-thread
addf pid.y.do-pid-calcs           servo-thread
addf pid.w.do-pid-calcs           servo-thread
addf hm2_5i25.0.write             servo-thread
addf charge-pump                  servo-thread



###################################################################################
# Raster Mask - stream in laser on/off commands behind AXIS's back
# Input stream format: reset beam xop xarg
#   reset:  0=mask command 1=reset (begin mask sequence with "1 0 0 0", every other command starts with 0)
#   beam:   0=off 1=on
#   xop:    X axis comparison operation 0=less-or-equal 1=greater
#   xarg:   X axis comparison operand

loadrt streamer depth=256 cfg="bbbf"
net mask-reset     <= streamer.0.pin.0
net mask-beam      <= streamer.0.pin.1
net mask-xop       <= streamer.0.pin.2
net mask-xarg      <= streamer.0.pin.3
net mask-empty     <= streamer.0.empty
net mask-read => streamer.0.enable

# hardware reported X axis position
net motion-xpos-fb <= axis.0.joint-pos-fb

# mask-lte <= motion-xpos-fb < mask-xarg
addf comp-mask-lte mask-thread
net motion-xpos-fb => comp-mask-lte.in0
net mask-xarg => comp-mask-lte.in1
net mask-lte <= comp-mask-lte.out

# mask-test <= mask-xop ^ mask-lte
addf xor2-mask-test mask-thread
net mask-xop => xor2-mask-test.in0
net mask-lte => xor2-mask-test.in1
net mask-test <= xor2-mask-test.out

# if job is running, read only if test is true or reset
# if job is not running, read until reset
# mask-read <= (laser-spindle && (mask-test || mask-reset)) || !(laser-spindle || mask-reset)

addf or2-mask-command-done mask-thread
net mask-test => or2-mask-command-done.in0
net mask-reset => or2-mask-command-done.in1
net mask-command-done <= or2-mask-command-done.out

addf and2-mask-forward mask-thread
net laser-spindle => and2-mask-forward.in0
net mask-command-done => and2-mask-forward.in1
net mask-forward <= and2-mask-forward.out

addf or2-mask-not-ffw mask-thread
net laser-spindle => or2-mask-not-ffw.in0
net mask-reset => or2-mask-not-ffw.in1
net mask-not-ffw <= or2-mask-not-ffw.out

addf not-mask-ffw mask-thread
net mask-not-ffw => not-mask-ffw.in
net mask-ffw <= not-mask-ffw.out

addf or2-mask-read mask-thread
net mask-forward => or2-mask-read.in0
net mask-ffw => or2-mask-read.in1
net mask-read <= or2-mask-read.out

# laser-gmask <=  mask-not-empty && mask-beam
addf not-mask-not-empty mask-thread
net mask-empty => not-mask-not-empty.in
net mask-not-empty <= not-mask-not-empty.out

addf and2-laser-gmask mask-thread
net mask-beam => and2-laser-gmask.in0
net mask-not-empty => and2-laser-gmask.in1
net laser-gmask <= and2-laser-gmask.out

addf streamer.0 mask-thread

#######################################################################
# Laser on/off logic

# coarse laser control, wired to spindle on/off (M3/M5), not realtime
net laser-spindle <= motion.spindle-on

# fine laser control, wired to digital output 0 (M62 P0/M63 P0), realtime
net laser-digital <= motion.digital-out-00

# Z axis laser control. Laser on iff motion controller's
# commanded Z position is < 0
addf comp-laser-zaxis servo-thread
net motion-zpos-joint axis.2.joint-pos-cmd => comp-laser-zaxis.in0
setp comp-laser-zaxis.in1 0
net laser-zaxis <= comp-laser-zaxis.out

# Loopback the Z motion controller so it always thinks
# that it's exactly where it wants to be
net motion-zpos-motor axis.2.motor-pos-cmd => axis.2.motor-pos-fb

# Generate fake jog to "retract" the Z axis automatically
# when spindle is off and Z < 0
addf not-jogger servo-thread
net jogger-pulse not-jogger.out => not-jogger.in

addf encoder.update-counters servo-thread
addf encoder.capture-position servo-thread
setp encoder.0.counter-mode 1
net jogger-pulse => encoder.0.phase-A
net jogger-counts encoder.0.counts => axis.2.jog-counts

addf not-amused servo-thread
setp axis.2.jog-scale 0.001
net laser-spindle => not-amused.in
addf and2-jogger servo-thread
net this-sucks not-amused.out => and2-jogger.in0
net laser-zaxis => and2-jogger.in1
net blow-me and2-jogger.out => axis.2.jog-enable

# laser-final <= laser-spindle & (laser-digital | laser-zaxis | laser-gmask)
addf or2-laser-gcode mask-thread
net laser-digital => or2-laser-gcode.in0
net laser-zaxis => or2-laser-gcode.in1
net laser-gcode <= or2-laser-gcode.out

addf or2-laser-fine mask-thread
net laser-gcode => or2-laser-fine.in0
net laser-gmask => or2-laser-fine.in1
net laser-fine <= or2-laser-fine.out

addf and2-laser-final mask-thread
net laser-fine => and2-laser-final.in0
net laser-spindle => and2-laser-final.in1
net laser-final <= and2-laser-final.out

# laser-final => DB25 pin 1

##################################################
# Laser power input pins

#hm2_5i25.0.gpio.017.in = 1000
#hm2_5i25.0.gpio.019.in = 0100
#hm2_5i25.0.gpio.021.in = 0010
#hm2_5i25.0.gpio.023.in = 0001
#hm2_5i25.0.gpio.025.in = defeat

##################################################
# Red dot laser
net red_dot_en <= bs1.red-dot-en

#Laser
setp hm2_5i25.0.gpio.027.is_output true
net red_dot_en => hm2_5i25.0.gpio.027.out

#Solenoid
setp hm2_5i25.0.gpio.026.is_output true
net red_dot_en => hm2_5i25.0.gpio.026.out


##################################################
# Variable Power ( via switches )

net pow8  => bs1.in-3   <= hm2_5i25.0.gpio.017.in
net pow4  => bs1.in-2   <= hm2_5i25.0.gpio.019.in
net pow2  => bs1.in-1   <= hm2_5i25.0.gpio.021.in
net pow1  => bs1.in-0   <= hm2_5i25.0.gpio.023.in
net pow_d => bs1.defeat <= hm2_5i25.0.gpio.025.in_not

##################################################
# Combine all power inputs and feed to PWM

net spindle-power 	motion.spindle-speed-out 	=> lpc1.power-in
net motion-vel 		motion.current-vel 		=> lpc1.vel-in
net requested-vel 	motion.requested-vel 		=> lpc1.gcode-requested-vel-in
net feed-override 	halui.feed-override.value 	=> lpc1.feed-override-in
#M3 => spindle forward => compatbility ON. M4 => spindle reverse => compatibliity OFF
net compatibility 	motion.spindle-forward 		=> lpc1.compatibility-in
net mask-beam 						=> lpc1.raster-in
net mask-not-empty 					=> lpc1.raster-on
net laser-digital 					=> lpc1.digital-in
net switch-override-in 	bs1.value-out 			=> lpc1.override-in

# min = tickle pulse, max < 1 because of low tube efficiency > 90%
setp lpc1.pwm-min 0.004
setp lpc1.pwm-max 0.94

net laser-power2 lpc1.pwm-out => hm2_5i25.0.pwmgen.00.value
net adaptive-feed lpc1.adaptive-out => motion.adaptive-feed

setp hm2_5i25.0.pwmgen.00.scale 1
setp hm2_5i25.0.pwmgen.pwm_frequency 5000
setp hm2_5i25.0.pwmgen.00.output-type 1
setp hm2_5i25.0.pwmgen.00.enable 1


##################################################
# Motion

#net unhome-x hm2_5i25.0.gpio.003.in => halui.joint.0.unhome 
#net unhome-y hm2_5i25.0.gpio.003.in => halui.joint.1.unhome 
#net unhome-w hm2_5i25.0.gpio.003.in => halui.joint.8.unhome 
net estop-ext => halui.joint.0.unhome 
net estop-ext => halui.joint.1.unhome 
net estop-ext => halui.joint.8.unhome 


# Send X amp enable to DB25 pin 16. This signal actually controls
# _all_ motors on the machine.
setp hm2_5i25.0.gpio.005.is_output true
setp hm2_5i25.0.gpio.005.invert_output true
net xenable => hm2_5i25.0.gpio.005.out

# Get limit switch signals from DB25 pin 13,12
net home-x hm2_5i25.0.gpio.016.in_not => axis.0.home-sw-in
net home-y hm2_5i25.0.gpio.015.in_not => axis.1.home-sw-in
#net limit-w hm2_5i25.0.gpio.014.in => axis.8.neg-lim-sw-in

# Get E-stop signal from DB25 pin 15
net estop-ext hm2_5i25.0.gpio.003.in => iocontrol.0.emc-enable-in

# X stepgen
setp   hm2_5i25.0.stepgen.00.position-scale  [AXIS_0]SCALE
setp   hm2_5i25.0.stepgen.00.steplen         [STEPGEN]STEP_LEN
setp   hm2_5i25.0.stepgen.00.stepspace       [STEPGEN]STEP_SPACE
setp   hm2_5i25.0.stepgen.00.dirhold         [STEPGEN]DIR_HOLD
setp   hm2_5i25.0.stepgen.00.dirsetup        [STEPGEN]DIR_SETUP
setp   hm2_5i25.0.stepgen.00.maxaccel         [AXIS_0]STEPGEN_MAXACCEL
setp   hm2_5i25.0.stepgen.00.maxvel           [AXIS_0]MAX_VELOCITY
setp   hm2_5i25.0.stepgen.00.step_type        0
setp   hm2_5i25.0.stepgen.00.control-type     1

# the recommended configuration is to use PID to drive hostmot2 stepgen in velocity mode
net xpos-cmd axis.0.motor-pos-cmd => pid.x.command
net xpos-fb hm2_5i25.0.stepgen.00.position-fb => axis.0.motor-pos-fb
net xpos-fb =>  pid.x.feedback
net xenable axis.0.amp-enable-out => hm2_5i25.0.stepgen.00.enable
net x-index-enable  <=> pid.x.index-enable
net xenable        =>  pid.x.enable
net x-vel-cmd       =>  pid.x.command-deriv
net x-vel-cmd    <= axis.0.joint-vel-cmd
net x-output        =>  pid.x.output
net x-output     <= hm2_5i25.0.stepgen.00.velocity-cmd

setp   pid.x.Pgain     [AXIS_0]P
setp   pid.x.Igain     [AXIS_0]I
setp   pid.x.Dgain     [AXIS_0]D
setp   pid.x.bias      [AXIS_0]BIAS
setp   pid.x.FF0       [AXIS_0]FF0
setp   pid.x.FF1       [AXIS_0]FF1
setp   pid.x.FF2       [AXIS_0]FF2
setp   pid.x.deadband  [AXIS_0]DEADBAND
setp   pid.x.maxoutput [AXIS_0]MAX_OUTPUT
setp   pid.x.error-previous-target true
setp   pid.x.maxerror .0005

# Y stepgen
setp   hm2_5i25.0.stepgen.01.position-scale  [AXIS_1]SCALE
setp   hm2_5i25.0.stepgen.01.steplen         [STEPGEN]STEP_LEN
setp   hm2_5i25.0.stepgen.01.stepspace       [STEPGEN]STEP_SPACE
setp   hm2_5i25.0.stepgen.01.dirhold         [STEPGEN]DIR_HOLD
setp   hm2_5i25.0.stepgen.01.dirsetup        [STEPGEN]DIR_SETUP
setp   hm2_5i25.0.stepgen.01.maxaccel         [AXIS_1]STEPGEN_MAXACCEL
setp   hm2_5i25.0.stepgen.01.maxvel           [AXIS_1]MAX_VELOCITY
setp   hm2_5i25.0.stepgen.01.step_type        0
setp   hm2_5i25.0.stepgen.01.control-type     1

# the recommended configuration is to use PID to drive hostmot2 stepgen in velocity mode
net ypos-cmd axis.1.motor-pos-cmd => pid.y.command
net ypos-fb hm2_5i25.0.stepgen.01.position-fb => axis.1.motor-pos-fb
net ypos-fb =>  pid.y.feedback
net yenable axis.1.amp-enable-out => hm2_5i25.0.stepgen.01.enable
net y-index-enable  <=> pid.y.index-enable
net yenable        =>  pid.y.enable
net y-vel-cmd       =>  pid.y.command-deriv
net y-vel-cmd    <= axis.1.joint-vel-cmd
net y-output        =>  pid.y.output
net y-output     <= hm2_5i25.0.stepgen.01.velocity-cmd

setp   pid.y.Pgain     [AXIS_1]P
setp   pid.y.Igain     [AXIS_1]I
setp   pid.y.Dgain     [AXIS_1]D
setp   pid.y.bias      [AXIS_1]BIAS
setp   pid.y.FF0       [AXIS_1]FF0
setp   pid.y.FF1       [AXIS_1]FF1
setp   pid.y.FF2       [AXIS_1]FF2
setp   pid.y.deadband  [AXIS_1]DEADBAND
setp   pid.y.maxoutput [AXIS_1]MAX_OUTPUT
setp   pid.y.error-previous-target true
setp   pid.y.maxerror .0005

# W stepgen
setp   hm2_5i25.0.stepgen.02.position-scale  [AXIS_8]SCALE
setp   hm2_5i25.0.stepgen.02.steplen         [STEPGEN]STEP_LEN
setp   hm2_5i25.0.stepgen.02.stepspace       [STEPGEN]STEP_SPACE
setp   hm2_5i25.0.stepgen.02.dirhold         [STEPGEN]DIR_HOLD
setp   hm2_5i25.0.stepgen.02.dirsetup        [STEPGEN]DIR_SETUP
setp   hm2_5i25.0.stepgen.02.maxaccel         [AXIS_8]STEPGEN_MAXACCEL
setp   hm2_5i25.0.stepgen.02.maxvel           [AXIS_8]MAX_VELOCITY
setp   hm2_5i25.0.stepgen.02.step_type        0
setp   hm2_5i25.0.stepgen.02.control-type     1

# the recommended configuration is to use PID to drive hostmot2 stepgen in velocity mode
net wpos-cmd axis.8.motor-pos-cmd => pid.w.command
net wpos-fb hm2_5i25.0.stepgen.02.position-fb => axis.8.motor-pos-fb
net wpos-fb =>  pid.w.feedback
net wenable axis.8.amp-enable-out => hm2_5i25.0.stepgen.02.enable
net w-index-enable  <=> pid.w.index-enable
net wenable        =>  pid.w.enable
net w-vel-cmd       =>  pid.w.command-deriv
net w-vel-cmd    <= axis.8.joint-vel-cmd
net w-output        =>  pid.w.output
net w-output     <= hm2_5i25.0.stepgen.02.velocity-cmd

setp   pid.w.Pgain     [AXIS_8]P
setp   pid.w.Igain     [AXIS_8]I
setp   pid.w.Dgain     [AXIS_8]D
setp   pid.w.bias      [AXIS_8]BIAS
setp   pid.w.FF0       [AXIS_8]FF0
setp   pid.w.FF1       [AXIS_8]FF1
setp   pid.w.FF2       [AXIS_8]FF2
setp   pid.w.deadband  [AXIS_8]DEADBAND
setp   pid.w.maxoutput [AXIS_8]MAX_OUTPUT
setp   pid.w.error-previous-target true
setp   pid.w.maxerror .0005

# Send charge pump signal to DB25 pin 17
setp hm2_5i25.0.gpio.007.is_output true
net charge-pump charge-pump.out => hm2_5i25.0.gpio.007.out

setp charge-pump.enable 1


##################################################
# Other Logics

loadusr linuxcncrsh
