component laserpwmcalc "Compute laser PWM value from required power, current velocity, and available laser power";
pin in float power_in = 0 "Required power density (power fraction/machine unit) = material severance energy (J/mm^2) * material thickness (mm) / machine output power (W)";
pin in float vel_in "Current velocity from motion.current-vel";
pin in float gcode_requested_vel_in "motion.requested-vel";
pin in float feed_override_in "halui.feed-override.value";
pin in bit compatibility_in = 1 "Backwards compatibility mode enable.";
pin in bit raster_in = 1 "Raster power scale factor. From graster";
pin in bit raster_on = 1 "Raster beam allow. From graster";
pin in bit digital_in = 1 "Fast, motion synchronized switch from motion.digital-out";
pin in float override_in = 1 "Additional override scaling factor";

param rw float pwm_min "Minimum PWM output value (where laser DOES fire)";
param rw float pwm_max "Minimum PWM output value (if laser saturates before 1.0)";
param rw float pwm_tickle "Tickle pulse pwm (highest where laser WILL NOT fire.";

pin out float pwm_out = 0 "PWM duty cycle to pwmgen.value (0 to 1.0)";
pin out float adaptive_out = 1 "Adaptive feed control to motion.adaptive-feed";
pin out float dbg_desired_power = 0 "desired power";
pin out float dbg_final_power = 0 "final power";
pin out float dbg_req_vel = 0 "requested velocity total";
pin out float dbg_max_vel = 0 "computed max velocity";
function _;
license "GPL";
;;

FUNCTION(_) {
	int beam_on = raster_on || digital_in;
	double desired_power = 0;
	double adaptive_out_tmp = 1;
	double final_power;
	double pwm;
	double requested_vel_in = gcode_requested_vel_in * feed_override_in; //Final commanded speed, in machine units.
	double standard_speed__ipm = 60.0;
	
	dbg_req_vel = requested_vel_in;
	
	if (beam_on) 
	{
		desired_power = (power_in > 0) ? power_in : -1 * power_in; //Absolute value of power_in
		
		//if(compatibility_in && desired_power > 0) //Ignore spindle scaling factor in compatibility mode.
		//{
		//	desired_power = 1/requested_vel_in; 
		//}
		desired_power = desired_power * (raster_on ? raster_in * 1.0 : 1.0) * override_in;
	}
	
	if(!compatibility_in) //Compatibility disables adaptive-feed
	{
		if(desired_power > 0 && requested_vel_in > 0) //Don't divide by zero
		{
			double max_vel = (standard_speed__ipm / 60) / desired_power; //Compute highest speed at we could achieve the requested power [ips]
			dbg_max_vel = max_vel;
			
			adaptive_out_tmp = max_vel / requested_vel_in; //If max_vel is F200 and requested_vel_in is F400, adaptive_out = 0.5
			if(adaptive_out_tmp > 1)
			{
				adaptive_out_tmp = 1;
			}
		}
	}

	adaptive_out = adaptive_out_tmp;
	
	dbg_desired_power = desired_power;
	
	
	if(compatibility_in)
	{
		final_power = desired_power;
	}
	else
	{
		if(vel_in == 0) //Don't allow laser to fire while stationary. In the future this should be possible for users to do this manually.
		{
			final_power = 0;
		}
		else //Slower motion will reduce laser power accordingly.
		{	
			final_power = desired_power * vel_in;
		}
	}
	dbg_final_power = final_power;
	
	if(final_power == 0)
	{
		pwm = pwm_tickle;
	}
	else
	{
		pwm = final_power * (pwm_max - pwm_min) + pwm_min;

		if (pwm > pwm_max) pwm = pwm_max;
		if (pwm < pwm_min) pwm = pwm_min;
	}
	pwm_out = pwm;
}
